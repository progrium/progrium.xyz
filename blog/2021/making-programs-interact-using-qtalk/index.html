<html>
  <head>
    <meta charset="UTF-8"/>
    <link rel="alternate" type="application/rss+xml" title="progrium.xyz RSS" href="https://progrium.xyz/blog/feed.xml"/>
    <script src="/assets/vnd/tailwind-3.2.4.min.js"></script>
    <link href="/assets/glider.svg" rel="icon"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css"/>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500&display=swap" rel="stylesheet"/>
    <link href="/assets/style.css" rel="stylesheet"/>
    <title>
      Making programs interact using qtalk :: progrium.xyz
    </title>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:creator" content="@progrium"/>
    <meta property="og:locale" content="en"/>
    <meta property="og:type" content="article"/>
    <meta property="og:site_name" content="progrium.xyz"/>
    <meta property="og:title" content="Making programs interact using qtalk"/>
    <meta content="qtalk-go is a versatile IPC/RPC library for Go" property="og:description"/>
    <meta property="og:url" content="https://progrium.xyz/blog/2021/making-programs-interact-using-qtalk"/>
    <meta name="twitter:image" content="https://progrium.xyz/photo_wide.png"/>
    <meta property="og:image" content="https://progrium.xyz/photo_wide.png"/>
    <meta property="og:image:width" content="2048"/>
    <meta property="og:image:height" content="1024"/>
    <meta property="article:published_time" content="2021-08-24T00:00:00+00:00"/>
  </head>
  <body class="bg-black">
    <header class="bg-white py-12">
      <nav class="mx-auto max-w-2xl">
        <div class="flex w-full items-center justify-between">
          <div class="flex items-end">
            <a class="text-xl font-black decoration-solid" href="/">
              progrium.xyz
            </a>
            <div class="space-x-8 ml-10" style="padding-bottom: 1px;">
              <a href="/blog" class="text-base decoration-solid font-normal hover:text-gray-500">
                Blog
              </a>
              <a href="https://progrium.com" target="_blank" class="text-base decoration-solid font-normal hover:text-gray-500">
                Work
                <svg class="inline ml-1" style="margin-bottom: 3px;" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor">
                  <path fill-rule="evenodd" d="M8.636 3.5a.5.5 0 0 0-.5-.5H1.5A1.5 1.5 0 0 0 0 4.5v10A1.5 1.5 0 0 0 1.5 16h10a1.5 1.5 0 0 0 1.5-1.5V7.864a.5.5 0 0 0-1 0V14.5a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h6.636a.5.5 0 0 0 .5-.5z"></path>
                  <path fill-rule="evenodd" d="M16 .5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0 0 1h3.793L6.146 9.146a.5.5 0 1 0 .708.708L15 1.707V5.5a.5.5 0 0 0 1 0v-5z"></path>
                </svg>
              </a>
            </div>
          </div>
          <div class="space-x-4 flex">
            <a href="https://mas.to/@progrium" class="hover:text-gray-500">
              <span class="sr-only">
                Mastodon
              </span>
              <svg viewBox="0 0 20 20" class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                <path style="transform: translateX(2px) translateY(2px);" d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z"></path>
              </svg>
            </a>
            <a href="https://twitter.com/progrium" class="hover:text-gray-500">
              <span class="sr-only">
                Twitter
              </span>
              <svg fill="currentColor" viewBox="0 0 24 24" aria-hidden="true" class="h-6 w-6">
                <path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path>
              </svg>
            </a>
            <a href="https://github.com/progrium" class="hover:text-gray-500">
              <span class="sr-only">
                GitHub
              </span>
              <svg class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                <path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"></path>
              </svg>
            </a>
            <a class="hover:text-gray-500" style="margin-top: 2px;" href="https://www.youtube.com/c/progrium">
              <span class="sr-only">
                YouTube
              </span>
              <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 576 512">
                <path d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path>
              </svg>
            </a>
            <a href="https://www.twitch.tv/progrium" class="hover:text-gray-500" style="margin-top: 3px;">
              <span class="sr-only">
                Twitch
              </span>
              <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 512 512">
                <path d="M391.17,103.47H352.54v109.7h38.63ZM285,103H246.37V212.75H285ZM120.83,0,24.31,91.42V420.58H140.14V512l96.53-91.42h77.25L487.69,256V0ZM449.07,237.75l-77.22,73.12H294.61l-67.6,64v-64H140.14V36.58H449.07Z"></path>
              </svg>
            </a>
          </div>
        </div>
      </nav>
    </header>
    <section style="min-height: 50vh;" class="bg-white flex flex-col justify-center pb-16">
      <div class="mx-auto max-w-2xl">
        <main class="blog mb-8 max-w-xl">
          <div class="text-center">
            <span class="text-gray-400 text-sm font-bold">
              2021-08-24
            </span>
            <h1 class="mb-8">
              Making programs interact using qtalk
            </h1>
          </div>
          <div class="body mx-auto text-left text-gray-800">
            <p>
              Today I'm releasing a beta of
              <a href="https://github.com/progrium/qtalk-go">
                qtalk-go
              </a>
              , a versatile IPC/RPC library for Go. I've been using and iterating on it for 5 years to get it as simple and clear as possible.
            </p>
            <pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic">// client.go
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/codec&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/fn&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/talk&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	ctx <span style="color:#000;font-weight:bold">:=</span> context.<span style="color:#900;font-weight:bold">Background</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// use talk.Dial to get a client
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	client, err <span style="color:#000;font-weight:bold">:=</span> talk.<span style="color:#900;font-weight:bold">Dial</span>(<span style="color:#d14">&#34;tcp&#34;</span>, <span style="color:#d14">&#34;localhost:9999&#34;</span>, codec.JSONCodec{})
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#900;font-weight:bold">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">defer</span> client.<span style="color:#900;font-weight:bold">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// call Upper and print the string return value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">var</span> ret <span style="color:#458;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>	_, err = client.<span style="color:#900;font-weight:bold">Call</span>(ctx, <span style="color:#d14">&#34;Upper&#34;</span>, fn.Args{<span style="color:#d14">&#34;hello world&#34;</span>}, <span style="color:#000;font-weight:bold">&amp;</span>ret)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#900;font-weight:bold">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	log.<span style="color:#900;font-weight:bold">Println</span>(ret)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// call Error and expect err to be the returned error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	_, err = client.<span style="color:#900;font-weight:bold">Call</span>(ctx, <span style="color:#d14">&#34;Error&#34;</span>, fn.Args{<span style="color:#d14">&#34;user error&#34;</span>}, <span style="color:#000;font-weight:bold">nil</span>)
</span></span><span style="display:flex;"><span>	log.<span style="color:#900;font-weight:bold">Println</span>(err)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#998;font-style:italic">// HELLO WORLD
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#998;font-style:italic">// remote: user error [/Error]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span></code></pre>
            <p>
              qtalk is based on over a decade of building and cataloging approaches, patterns, anti-patterns, and best practices in network programming. My interest goes all the way back to high school when I first started playing with Winsock attempting to make massively multiplayer games. Then as a young web developer, pushing the limits of HTTP, discovering how to stream real-time to the browser years before Websocket was dreamed up. Then further abusing HTTP to model other protocols like DNS and IMAP. I pioneered distributed callbacks with webhooks, which got me working at early Twilio where I started going deep on scalable, highly-available messaging architectures. This led me into distributed systems: discovery, coordination, scheduling, etc. I've seen a lot.
            </p>
            <p>
              I originally wanted to release qtalk with a paper describing all the significant choices to consider when building a stack like this: message framing, data formats, transports, security mechanisms, protocol flows, queuing, multiplexing, batching, layering, schemas, IDLs, symmetrical vs asymmetrical, stateful vs stateless, TCP vs UDP, etc. It would be a sort of guide for building your own stack. I'd still like to write that at some point, but this post will have to suffice for now.
            </p>
            <p>
              <strong>
                qtalk makes no significant claims other than being the most bang for buck in simplicity and versatility.
              </strong>
              I've made a full walkthrough of various ways it can be used on the
              <a href="https://github.com/progrium/qtalk-go/wiki/Examples">
                wiki
              </a>
              , but I'll share a taste here.
            </p>
            <p>
              Here is the server to the client code from above for you to try. Together they show qtalk being used in the simplest case, traditional RPC:
            </p>
            <pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic">// server.go
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/codec&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/fn&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/rpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> service <span style="color:#000;font-weight:bold">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (svc <span style="color:#000;font-weight:bold">*</span>service) <span style="color:#900;font-weight:bold">Upper</span>(s <span style="color:#458;font-weight:bold">string</span>) <span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> strings.<span style="color:#900;font-weight:bold">ToUpper</span>(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// methods can opt-in to receive the call as last argument.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// also, errors can be returned to be received as remote errors.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (svc <span style="color:#000;font-weight:bold">*</span>service) <span style="color:#900;font-weight:bold">Error</span>(s <span style="color:#458;font-weight:bold">string</span>, c <span style="color:#000;font-weight:bold">*</span>rpc.Call) <span style="color:#458;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> fmt.<span style="color:#900;font-weight:bold">Errorf</span>(<span style="color:#d14">&#34;%s [%s]&#34;</span>, s, c.Selector)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// create a tcp listener
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	l, err <span style="color:#000;font-weight:bold">:=</span> net.<span style="color:#900;font-weight:bold">Listen</span>(<span style="color:#d14">&#34;tcp&#34;</span>, <span style="color:#d14">&#34;localhost:9999&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#900;font-weight:bold">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// setup a server using fn.HandlerFrom to
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#998;font-style:italic">// handle methods from the service type
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	srv <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>rpc.Server{
</span></span><span style="display:flex;"><span>		Codec:   codec.JSONCodec{},
</span></span><span style="display:flex;"><span>		Handler: fn.<span style="color:#900;font-weight:bold">HandlerFrom</span>(<span style="color:#0086b3">new</span>(service)),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// serve until the listener closes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	srv.<span style="color:#900;font-weight:bold">Serve</span>(l)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span></code></pre>
            <h2>
              Features
            </h2>
            <p>
              Some basic features of qtalk-go are:
            </p>
            <ul>
              <li>
                heavily
                <code>
                  net/http
                </code>
                inspired API
              </li>
              <li>
                pluggable format codecs
              </li>
              <li>
                optional reflection handlers for funcs and methods
              </li>
              <li>
                works over any
                <code>
                  io.ReadWriteCloser
                </code>
                , including STDIO
              </li>
              <li>
                easily portable to other languages
              </li>
            </ul>
            <p>
              The more unique features of qtalk-go I want to talk about are:
            </p>
            <ul>
              <li>
                connection multiplexing
              </li>
              <li>
                bidirectional calling
              </li>
            </ul>
            <h2>
              Multiplexing Layer
            </h2>
            <p>
              The connection multiplexing layer is based on
              <a href="https://github.com/progrium/qmux">
                qmux
              </a>
              , a subset of SSH that I've
              <a href="https://dev.to/progrium/the-history-and-future-of-socket-level-multiplexing-1d5n">
                written about previously
              </a>
              . It was designed to optionally be swapped out with QUIC as needed. Either way, everything in qtalk happens over flow-controlled channels, which can be used like embedded TCP streams. Whatever you do with qtalk, you can also tunnel other connections and protocols on the same connection.
            </p>
            <p>
              RPC is just a layer on top, where each call gets its own channel. This makes request/reply correlation simple, streaming call input/output easy, and lets you hijack the call channel to do something else without interrupting other calls. You can start with an RPC call and then let it become a full-duplex bytestream pipe. Imagine a call that provisions a database and then becomes a client connection to it.
            </p>
            <h2>
              Bidirectional Calling
            </h2>
            <p>
              Bidirectional calling allows both the client and server to make and respond to calls. Decoupling the caller and responder roles from the connection topology lets you implement patterns like the worker pattern, where a worker connects to a coordinator and responds to its calls.
            </p>
            <p>
              This also allows for various forms of callbacks in either direction. Not only do callbacks let you build more extensible services, but generally open up more ways for processes to talk to each other. Especially when combined with the other aspects of qtalk.
            </p>
            <p>
              Imagine a TCP proxy with an API letting services register a callback whenever a connection comes through, and the callback includes a tee of the client bytestream letting this external service monitor and maybe close the connection when it sees something it doesn't like.
            </p>
            <h2>
              State Synchronization
            </h2>
            <p>
              State synchronization isn't a feature but a common pattern you can easily implement in a number of ways with qtalk. While many people think about pubsub with messaging, which you can also implement with qtalk, I've learned you usually actually want state synchronization instead. Below is a simple example.
            </p>
            <p>
              Our server will have a list of usernames connected, which is our state. When a client connects, it calls Join to add its username to the list. This also registers the client to receive a callback passing the list of usernames whenever it changes. The client can then call Leave, or if it disconnects abruptly it will be unregistered with the next update.
            </p>
            <pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic">// server.go
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/codec&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/fn&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/rpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// State contains a map of usernames to callers,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// which are used as a callback client to that user
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> State <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	users sync.Map
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Users gets a list of usernames from the keys of the sync.Map
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>State) <span style="color:#900;font-weight:bold">Users</span>() (users []<span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>	s.users.<span style="color:#900;font-weight:bold">Range</span>(<span style="color:#000;font-weight:bold">func</span>(k, v <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>		users = <span style="color:#0086b3">append</span>(users, k.(<span style="color:#458;font-weight:bold">string</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Join adds a username and caller using the injected rpc.Call
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// value, then broadcasts the change
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>State) <span style="color:#900;font-weight:bold">Join</span>(username <span style="color:#458;font-weight:bold">string</span>, c <span style="color:#000;font-weight:bold">*</span>rpc.Call) {
</span></span><span style="display:flex;"><span>	s.users.<span style="color:#900;font-weight:bold">Store</span>(username, c.Caller)
</span></span><span style="display:flex;"><span>	s.<span style="color:#900;font-weight:bold">broadcast</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Leave removes the user from the sync.Map and broadcasts
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>State) <span style="color:#900;font-weight:bold">Leave</span>(username <span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>	s.users.<span style="color:#900;font-weight:bold">Delete</span>(username)
</span></span><span style="display:flex;"><span>	s.<span style="color:#900;font-weight:bold">broadcast</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// broadcast uses the rpc.Caller values to perform a callback
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// with the &#34;state&#34; selector, passing the current list of
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// usernames. any callers that return an error are added to
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// gone and then removed with Leave
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>State) <span style="color:#900;font-weight:bold">broadcast</span>() {
</span></span><span style="display:flex;"><span>	users <span style="color:#000;font-weight:bold">:=</span> s.<span style="color:#900;font-weight:bold">Users</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">var</span> gone []<span style="color:#458;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>	s.users.<span style="color:#900;font-weight:bold">Range</span>(<span style="color:#000;font-weight:bold">func</span>(k, v <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>		_, err <span style="color:#000;font-weight:bold">:=</span> v.(rpc.Caller).<span style="color:#900;font-weight:bold">Call</span>(context.<span style="color:#900;font-weight:bold">Background</span>(), <span style="color:#d14">&#34;state&#34;</span>, users, <span style="color:#000;font-weight:bold">nil</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			log.<span style="color:#900;font-weight:bold">Println</span>(k.(<span style="color:#458;font-weight:bold">string</span>), err)
</span></span><span style="display:flex;"><span>			gone = <span style="color:#0086b3">append</span>(gone, k.(<span style="color:#458;font-weight:bold">string</span>))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">for</span> _, u <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> gone {
</span></span><span style="display:flex;"><span>		s.<span style="color:#900;font-weight:bold">Leave</span>(u)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// create a tcp listener
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	l, err <span style="color:#000;font-weight:bold">:=</span> net.<span style="color:#900;font-weight:bold">Listen</span>(<span style="color:#d14">&#34;tcp&#34;</span>, <span style="color:#d14">&#34;localhost:9999&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#900;font-weight:bold">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// setup a server using fn.HandlerFrom to
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#998;font-style:italic">// handle methods from the state value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	srv <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>rpc.Server{
</span></span><span style="display:flex;"><span>		Codec:   codec.JSONCodec{},
</span></span><span style="display:flex;"><span>		Handler: fn.<span style="color:#900;font-weight:bold">HandlerFrom</span>(<span style="color:#0086b3">new</span>(State)),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// serve until the listener closes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	srv.<span style="color:#900;font-weight:bold">Serve</span>(l)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span></code></pre>
            <p>
              The Call pointer that handlers can receive has a reference to a Caller, which is a client to make calls back to the caller, allowing callbacks.
            </p>
            <p>
              Our client is straightforward. After setting up a connection and a handler to receive and display an updated username listing, we call Join with a username, wait for SIGINT, and call Leave before exiting.
            </p>
            <pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic">// client.go
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;flag&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;os/signal&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/codec&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/fn&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/rpc&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#34;github.com/progrium/qtalk-go/talk&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">fatal</span>(err <span style="color:#458;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#900;font-weight:bold">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	flag.<span style="color:#900;font-weight:bold">Parse</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// establish connection to server
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	client, err <span style="color:#000;font-weight:bold">:=</span> talk.<span style="color:#900;font-weight:bold">Dial</span>(<span style="color:#d14">&#34;tcp&#34;</span>, <span style="color:#d14">&#34;localhost:9999&#34;</span>, codec.JSONCodec{})
</span></span><span style="display:flex;"><span>	<span style="color:#900;font-weight:bold">fatal</span>(err)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// state callback handler that redraws the user list
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	client.<span style="color:#900;font-weight:bold">Handle</span>(<span style="color:#d14">&#34;state&#34;</span>, rpc.<span style="color:#900;font-weight:bold">HandlerFunc</span>(<span style="color:#000;font-weight:bold">func</span>(r rpc.Responder, c <span style="color:#000;font-weight:bold">*</span>rpc.Call) {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">var</span> users <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">:=</span> c.<span style="color:#900;font-weight:bold">Receive</span>(<span style="color:#000;font-weight:bold">&amp;</span>users); err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			log.<span style="color:#900;font-weight:bold">Println</span>(err)
</span></span><span style="display:flex;"><span>			<span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// the nonsense are terminal escape codes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// to return to the last line and clear it
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		fmt.<span style="color:#900;font-weight:bold">Println</span>(<span style="color:#d14">&#34;\u001B[1A\u001B[K&#34;</span>, users)
</span></span><span style="display:flex;"><span>	}))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// respond to incoming calls
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">go</span> client.<span style="color:#900;font-weight:bold">Respond</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// call Join passing a username from arguments
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	_, err = client.<span style="color:#900;font-weight:bold">Call</span>(context.<span style="color:#900;font-weight:bold">Background</span>(), <span style="color:#d14">&#34;Join&#34;</span>, fn.Args{flag.<span style="color:#900;font-weight:bold">Arg</span>(<span style="color:#099">0</span>)}, <span style="color:#000;font-weight:bold">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#900;font-weight:bold">fatal</span>(err)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// wait until we get SIGINT
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	ch <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> os.Signal)
</span></span><span style="display:flex;"><span>	signal.<span style="color:#900;font-weight:bold">Notify</span>(ch, os.Interrupt)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">&amp;</span>lt;<span style="color:#000;font-weight:bold">-</span>ch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// call Leave before finishing
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	_, err = client.<span style="color:#900;font-weight:bold">Call</span>(context.<span style="color:#900;font-weight:bold">Background</span>(), <span style="color:#d14">&#34;Leave&#34;</span>, fn.Args{flag.<span style="color:#900;font-weight:bold">Arg</span>(<span style="color:#099">0</span>)}, <span style="color:#000;font-weight:bold">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#900;font-weight:bold">fatal</span>(err)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span></code></pre>
            <p>
              See the
              <a href="https://github.com/progrium/qtalk-go/wiki/Examples">
                Examples wiki page
              </a>
              for more code examples, including tunnels and proxies, selector routing, and streaming responses.
            </p>
            <h2>
              Roadmap
            </h2>
            <p>
              I'm trying to get to a 1.0 for
              <a href="https://github.com/progrium/qtalk-go">
                qtalk-go
              </a>
              , so I'd like more people to use and review its code. I also haven't actually gotten around to
              <a href="https://github.com/progrium/qtalk-go/issues/2">
                putting in QUIC
              </a>
              as a usable base layer, which I think should be in a 1.0 release. It's in the name, qtalk was started with QUIC in mind. Not only will QUIC improve performance, resolve head of line blocking, and eventually be native to browsers, but being UDP-based means that hole punching can be used to establish peer-to-peer qtalk connections. I'd like to one day be able to use qtalk directly between machines behind NAT.
            </p>
            <p>
              Meanwhile, I'm wrapping up a JavaScript implementation (in TypeScript) to officially release soon. I have the start of a Python implementation I could use help with, and I'd love to have a C# implementation.
            </p>
            <p>
              That's it for now. A big thanks to my
              <a href="https://github.com/sponsors/progrium">
                sponsors
              </a>
              for making this happen and thanks to you for reading!
            </p>
            <hr>
            <p>
              <em>
                For more great posts like this sent directly to your inbox and to find out what all I'm up to, get on the list at
                <a href="http://progrium.com">
                  progrium.com
                </a>
                ✌️
              </em>
            </p>
          </div>
        </main>
      </div>
    </section>
    <footer class="bg-black py-16">
      <div class="mx-auto max-w-2xl">
        <div class="xl:grid xl:grid-cols-4 xl:gap-8">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-8 h-8" viewbox="0 0 140 140" stroke="white">
            <path stroke-width="122" stroke-dasharray="2,38" d="m9,70h122M70,9v122"></path>
            <path d="m70,30h0m40,40h0m-80,40v0m40,0h0m40,0h0" stroke-width="33" stroke-linecap="round"></path>
          </svg>
          <div class="mt-16 grid grid-cols-2 gap-8 xl:col-span-3 xl:mt-0">
            <div class="md:grid md:grid-cols-2 md:gap-8">
              <div>
                <span class="text-sm font-semibold leading-6 text-white">
                  progrium.xyz
                </span>
                <ul role="list" class="mt-2">
                  <li>
                    <a href="/" class="text-sm leading-6 text-gray-300 hover:text-white">
                      Home
                    </a>
                  </li>
                  <li>
                    <a href="/blog" class="text-sm leading-6 text-gray-300 hover:text-white">
                      Blog
                    </a>
                  </li>
                  <li>
                    <a class="text-sm leading-6 text-gray-300 hover:text-white" href="https://progrium.com">
                      Work
                    </a>
                  </li>
                </ul>
              </div>
              <div class="mt-10 md:mt-0">
                <span class="text-sm font-semibold leading-6 text-white">
                  Follow
                </span>
                <ul role="list" class="mt-2">
                  <li>
                    <a href="https://mas.to/@progrium" class="text-sm leading-6 text-gray-300 hover:text-white">
                      Mastodon
                    </a>
                  </li>
                  <li>
                    <a href="https://twitter.com/progrium" class="text-sm leading-6 text-gray-300 hover:text-white">
                      Twitter
                    </a>
                  </li>
                  <li>
                    <a href="https://github.com/progrium" class="text-sm leading-6 text-gray-300 hover:text-white">
                      GitHub
                    </a>
                  </li>
                </ul>
              </div>
            </div>
            <div class="md:grid md:grid-cols-2 md:gap-8">
              <div>
                <span class="text-sm font-semibold leading-6 text-white">
                  Content
                </span>
                <ul role="list" class="mt-2">
                  <li>
                    <a href="https://www.youtube.com/c/progrium" class="text-sm leading-6 text-gray-300 hover:text-white">
                      YouTube
                    </a>
                  </li>
                  <li>
                    <a href="https://www.twitch.tv/progrium" class="text-sm leading-6 text-gray-300 hover:text-white">
                      Twitch
                    </a>
                  </li>
                  <li>
                    <a class="text-sm leading-6 text-gray-300 hover:text-white" href="https://soundcloud.com/progrium">
                      Soundcloud
                    </a>
                  </li>
                  <li>
                    <a href="https://progrium.itch.io/" class="text-sm leading-6 text-gray-300 hover:text-white">
                      itch.io
                    </a>
                  </li>
                </ul>
              </div>
              <div class="mt-10 md:mt-0">
                <span class="text-sm font-semibold leading-6 text-white">
                  Contact
                </span>
                <ul role="list" class="mt-2">
                  <li>
                    <a href="mailto:progrium+web@gmail.com" class="text-sm leading-6 text-gray-300 hover:text-white">
                      Email
                    </a>
                  </li>
                  <li>
                    <a href="https://discord.gg/JraBdNHuuP" class="text-sm leading-6 text-gray-300 hover:text-white">
                      Discord
                    </a>
                  </li>
                  <li>
                    <a href="https://www.linkedin.com/in/progrium/" class="text-sm leading-6 text-gray-300 hover:text-white">
                      LinkedIn
                    </a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>